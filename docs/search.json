[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Jalal El Hazzat",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn‚Äôt specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "posts/my-first-post/index.html",
    "href": "posts/my-first-post/index.html",
    "title": "My First Post",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My First Quarto Blog",
    "section": "",
    "text": "Kane Equations of Motion\n\n\n\nmultibody\n\nreference frame\n\nrotation\n\nKane\n\n\n\nA post about multibody dynamics\n\n\n\n\n\n\nJun 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nRotation Matrix\n\n\n\nmultibody\n\nreference frame\n\nrotation\n\n\n\nA post about sympy generated rotation matrix\n\n\n\n\n\n\nJun 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nPost With Code\n\n\n\nnews\n\ncode\n\nanalysis\n\n\n\n\n\n\n\nHarlow Malloc\n\n\nJun 10, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nMy First Post\n\n\n\nmath\n\nspace\n\ncontrol\n\n\n\n\n\n\n\nJalal El Hazzat\n\n\nJun 8, 2025\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\nTristan O‚ÄôMalley\n\n\nJun 7, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/rotation-matrix/sympy-rotation-quarto.html",
    "href": "posts/rotation-matrix/sympy-rotation-quarto.html",
    "title": "Rotation Matrix",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\npd.set_option(\"display.max_rows\", 1000)\n\nimport sympy as sm\nimport sympy.physics.mechanics as me\n\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\n\nsm.init_printing()\n\n\ntheta, alpha = sm.symbols('theta, alpha')\n\nB_C_A = sm.Matrix([\n    [sm.cos(theta), sm.sin(theta), 0],\n    [-sm.sin(theta), sm.cos(theta), 0],\n    [0, 0, 1],\n])\n\nC_C_B = sm.Matrix([\n    [1, 0, 0],\n    [0, sm.cos(alpha), sm.sin(alpha)],\n    [0, -sm.sin(alpha), sm.cos(alpha)],\n])\n\nB_C_A\n\nC_C_B\n\n\\(\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} & 0\\\\- \\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0\\\\0 & \\cos{\\left(\\alpha \\right)} & \\sin{\\left(\\alpha \\right)}\\\\0 & - \\sin{\\left(\\alpha \\right)} & \\cos{\\left(\\alpha \\right)}\\end{matrix}\\right]\\)\n\n\n\nC_C_A = C_C_B * B_C_A\n\nC_C_A\n\n\\(\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} & 0\\\\- \\sin{\\left(\\theta \\right)} \\cos{\\left(\\alpha \\right)} & \\cos{\\left(\\alpha \\right)} \\cos{\\left(\\theta \\right)} & \\sin{\\left(\\alpha \\right)}\\\\\\sin{\\left(\\alpha \\right)} \\sin{\\left(\\theta \\right)} & - \\sin{\\left(\\alpha \\right)} \\cos{\\left(\\theta \\right)} & \\cos{\\left(\\alpha \\right)}\\end{matrix}\\right]\\)\n\n\n\nA = me.ReferenceFrame('A')\nB = me.ReferenceFrame('B')\nC = me.ReferenceFrame('C')\n\n\nA.x, A.y, A.z\n\n\\(\\displaystyle \\left( \\mathbf{\\hat{a}_x}, \\  \\mathbf{\\hat{a}_y}, \\  \\mathbf{\\hat{a}_z}\\right)\\)\n\n\n\nB.orient_axis(A, theta, A.z)\nB.dcm(A)\n\n\\(\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} & 0\\\\- \\sin{\\left(\\theta \\right)} & \\cos{\\left(\\theta \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]\\)\n\n\n\nC.orient_axis(B, alpha, B.x)\nC.dcm(B)\n\n\\(\\displaystyle \\left[\\begin{matrix}1 & 0 & 0\\\\0 & \\cos{\\left(\\alpha \\right)} & \\sin{\\left(\\alpha \\right)}\\\\0 & - \\sin{\\left(\\alpha \\right)} & \\cos{\\left(\\alpha \\right)}\\end{matrix}\\right]\\)\n\n\n\nC.dcm(A)\n\n\\(\\displaystyle \\left[\\begin{matrix}\\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} & 0\\\\- \\sin{\\left(\\theta \\right)} \\cos{\\left(\\alpha \\right)} & \\cos{\\left(\\alpha \\right)} \\cos{\\left(\\theta \\right)} & \\sin{\\left(\\alpha \\right)}\\\\\\sin{\\left(\\alpha \\right)} \\sin{\\left(\\theta \\right)} & - \\sin{\\left(\\alpha \\right)} \\cos{\\left(\\theta \\right)} & \\cos{\\left(\\alpha \\right)}\\end{matrix}\\right]\\)\n\n\n\nA = me.ReferenceFrame('A')\nC = me.ReferenceFrame('C')\n\n\npsi, theta, phi = sm.symbols('psi, theta, varphi')\n\n\nC.orient_body_fixed(A, (psi, theta, phi), 'ZXZ')\nC.dcm(A)\n\n\\(\\displaystyle \\left[\\begin{matrix}- \\sin{\\left(\\psi \\right)} \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\theta \\right)} + \\cos{\\left(\\psi \\right)} \\cos{\\left(\\varphi \\right)} & \\sin{\\left(\\psi \\right)} \\cos{\\left(\\varphi \\right)} + \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\psi \\right)} \\cos{\\left(\\theta \\right)} & \\sin{\\left(\\theta \\right)} \\sin{\\left(\\varphi \\right)}\\\\- \\sin{\\left(\\psi \\right)} \\cos{\\left(\\theta \\right)} \\cos{\\left(\\varphi \\right)} - \\sin{\\left(\\varphi \\right)} \\cos{\\left(\\psi \\right)} & - \\sin{\\left(\\psi \\right)} \\sin{\\left(\\varphi \\right)} + \\cos{\\left(\\psi \\right)} \\cos{\\left(\\theta \\right)} \\cos{\\left(\\varphi \\right)} & \\sin{\\left(\\theta \\right)} \\cos{\\left(\\varphi \\right)}\\\\\\sin{\\left(\\psi \\right)} \\sin{\\left(\\theta \\right)} & - \\sin{\\left(\\theta \\right)} \\cos{\\left(\\psi \\right)} & \\cos{\\left(\\theta \\right)}\\end{matrix}\\right]\\)"
  },
  {
    "objectID": "posts/kane-equations/GAF-and-GIF-Rigid-Body-Quarto.html",
    "href": "posts/kane-equations/GAF-and-GIF-Rigid-Body-Quarto.html",
    "title": "Kane Equations of Motion",
    "section": "",
    "text": "import sympy as sm\nimport sympy.physics.mechanics as me\nme.init_vprinting()\n\nimport numpy as np\nfrom IPython.display import SVG, display\n\nfrom IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\nA multibody system comprised of two uniformly dense thin rods of length \\(l\\) and mass \\(ùëö\\). Rod \\(ùê¥\\) is pinned at \\(ùëÇ\\) and can rotate about \\(\\hat{n}_{z}\\) through \\(q_{1}\\). Rod \\(B\\) is pinned to \\(A\\) and can rotate relative to \\(A\\) about \\(\\hat{a}_{x}\\) through \\(q_{2}\\). Linear torisional springs of stiffnes \\(k\\) with a free length of zero resists each relative rotation. Gravitational forces are in the \\(\\hat{n}_{x}\\) direction.\n\nsvg_path = \"/Users/jalalelhazzat/Documents/DEV2023/jnbooks/Multibody/Images/Generalised-Forces-Rigid-Body.svg\"\ndisplay(SVG(filename=svg_path))\n\n\n\n\n\n\n\n\n\nREFERENCE FRAME AND VARIABLES SETUP\n\nl, m, g, k = sm.symbols('l, m, g, k')\nq1, q2, u1, u2 = me.dynamicsymbols('q1, q2, u1, u2')\nt = me.dynamicsymbols._t\n\nN = me.ReferenceFrame('N')\nA = me.ReferenceFrame('A')\nB = me.ReferenceFrame('B')\n\nA.orient_axis(N, q1, N.z)\nB.orient_axis(A, q2, A.x)\n\nprint(f\"Below we display the Direction Cosine Matrices of reference frame A and B \"\n      f\"with respect to reference frame N \\n\")\n\nA.dcm(N)\nB.dcm(N)\n\nBelow we display the Direction Cosine Matrices of reference frame A and B with respect to reference frame N \n\n\n\n\\(\\displaystyle \\left[\\begin{matrix}\\cos{\\left(q_{1} \\right)} & \\sin{\\left(q_{1} \\right)} & 0\\\\- \\sin{\\left(q_{1} \\right)} & \\cos{\\left(q_{1} \\right)} & 0\\\\0 & 0 & 1\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}\\cos{\\left(q_{1} \\right)} & \\sin{\\left(q_{1} \\right)} & 0\\\\- \\sin{\\left(q_{1} \\right)} \\cos{\\left(q_{2} \\right)} & \\cos{\\left(q_{1} \\right)} \\cos{\\left(q_{2} \\right)} & \\sin{\\left(q_{2} \\right)}\\\\\\sin{\\left(q_{1} \\right)} \\sin{\\left(q_{2} \\right)} & - \\sin{\\left(q_{2} \\right)} \\cos{\\left(q_{1} \\right)} & \\cos{\\left(q_{2} \\right)}\\end{matrix}\\right]\\)\n\n\n\n\nKINEMATICS\n\nO = me.Point('O')\nA0 = me.Point('A0')\nB0 = me.Point('B0')\n\nA0.set_pos(O, 0.5 * l * A.x)\nB0.set_pos(O, l * A.x)\n\nA0.pos_from(O).express(N)\nB0.pos_from(A0).express(N)\n\n\\(\\displaystyle 0.5 l \\cos{\\left(q_{1} \\right)}\\mathbf{\\hat{n}_x} + 0.5 l \\sin{\\left(q_{1} \\right)}\\mathbf{\\hat{n}_y}\\)\n\n\n\\(\\displaystyle 0.5 l \\cos{\\left(q_{1} \\right)}\\mathbf{\\hat{n}_x} + 0.5 l \\sin{\\left(q_{1} \\right)}\\mathbf{\\hat{n}_y}\\)\n\n\n\nA.set_ang_vel(N, q1.diff(t) * N.z)\nB.set_ang_vel(A, q2.diff(t) * A.x)\n\nA.ang_vel_in(N)\nB.ang_vel_in(N)\n\n\\(\\displaystyle \\dot{q}_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\\(\\displaystyle \\dot{q}_{2}\\mathbf{\\hat{a}_x} + \\dot{q}_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\nO.set_vel(N, 0)\n_ = A0.v2pt_theory(O, N, A)\n\nA0.set_vel(A, 0)\n_ = B0.v2pt_theory(A0, A, B)\n\nA0.vel(N)\nB0.vel(N)\n\n\\(\\displaystyle 0.5 l \\dot{q}_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle l \\dot{q}_{1}\\mathbf{\\hat{a}_y}\\)\n\n\nWe choose the generalised speeds to be equal to the inertial time derivative of generalised coordinates:\n\\[\n    u_{1} = \\dot{q}_{1}\n    u_{2} = \\dot{q}_{2}\n\\]\nWe then rewrite velocities and angular velocities replacing instances of \\(\\dot{q}_{1}\\) and \\(\\dot{q}_{2}\\) with \\(u_{1}\\) and \\(u_{2}\\)\n\ngeneralised_speeds = {q1.diff(): u1, q2.diff(): u2}\n\nN_v_A0 = A0.vel(N).xreplace(generalised_speeds)\nN_v_B0 = B0.vel(N).xreplace(generalised_speeds)\n\nN_v_A0\nN_v_B0\n\nN_w_A = A.ang_vel_in(N).xreplace(generalised_speeds)\nN_w_B = B.ang_vel_in(N).xreplace(generalised_speeds)\n\nN_w_A\nN_w_B\n\n\\(\\displaystyle 0.5 l u_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle l u_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle u_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\\(\\displaystyle u_{2}\\mathbf{\\hat{a}_x} + u_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\nPARTIAL VELOCITIES\nTo compute the partial velocities \\(\\boldsymbol{v}_{r}\\) we compute the partial derivatives of the velocities for both bodies \\(A\\) and \\(B\\) with respect to \\(u_{r}\\).\n\nv_A0_1 = N_v_A0.diff(u1, N)\nv_A0_2 = N_v_A0.diff(u2, N)\nv_A0_t = N_v_A0.xreplace({u1: 0, u2: 0})\n\nv_B0_1 = N_v_B0.diff(u1, N)\nv_B0_2 = N_v_B0.diff(u2, N)\nv_B0_t = N_v_B0.xreplace({u1: 0, u2: 0})\n\nv_A0_1, v_A0_2, v_A0_t\nv_B0_1, v_B0_2, v_B0_t\n\n\\(\\displaystyle \\left( 0.5 l\\mathbf{\\hat{a}_y}, \\  0, \\  0\\right)\\)\n\n\n\\(\\displaystyle \\left( l\\mathbf{\\hat{a}_y}, \\  0, \\  0\\right)\\)\n\n\n\n# generalised_speeds = {q1.diff(): u1, q2.diff(): u2}\n\n# N_w_A = A.ang_vel_in(N).xreplace(generalised_speeds)\n# N_w_B = B.ang_vel_in(N).xreplace(generalised_speeds)\n\n# N_w_A\n# N_w_B\n\n\n\nPARTIAL ANGULAR VELOCITIES\nTo compute the partial angular velocities \\(\\boldsymbol{\\omega}_{r}\\) we compute the partial derivatives of the angular velocities for both bodies \\(A\\) and \\(B\\) with respect to \\(u_{r}\\).\n\nw_A_1 = N_w_A.diff(u1, N)\nw_A_2 = N_w_A.diff(u2, N)\nw_A_t = N_w_A.xreplace({u1: 0, u2: 0})\n\nw_B_1 = N_w_B.diff(u1, N)\nw_B_2 = N_w_B.diff(u2, N)\nw_B_t = N_w_B.xreplace({u1: 0, u2: 0})\n\nw_A_1, w_A_2, w_A_t\nw_B_1, w_B_2, w_B_t\n\n\\(\\displaystyle \\left( \\mathbf{\\hat{n}_z}, \\  0, \\  0\\right)\\)\n\n\n\\(\\displaystyle \\left( \\mathbf{\\hat{n}_z}, \\  \\mathbf{\\hat{a}_x}, \\  0\\right)\\)\n\n\n\n\n\nGENERALISED ACTIVE FORCES\n\nR_Ao = m * g * N.x\nR_Bo = m * g * N.x\n\nF1 = me.dot(v_A0_1, R_Ao) + me.dot(v_B0_1, R_Bo)\nF2 = me.dot(v_A0_2, R_Ao) + me.dot(v_B0_2, R_Bo)\n\nT_A = -k * q1 * N.z + k * q2 * A.x\nT_B = -k * q2 * A.x\n\nT1 = me.dot(w_A_1, T_A) + me.dot(w_B_1, T_B)\nT2 = me.dot(w_A_2, T_A) + me.dot(w_B_2, T_B)\n\n\nGAF = sm.Matrix([F1 + T1, F2 + T2])\nGAF\n\n\\(\\displaystyle \\left[\\begin{matrix}- 1.5 g l m \\sin{\\left(q_{1} \\right)} - k q_{1}\\\\- k q_{2}\\end{matrix}\\right]\\)\n\n\n\nANOTHER WAY\n\n\n\nGENERALISED INERTIA FORCES\n\nA0.vel(N)\nB0.vel(N)\n\nA.ang_vel_in(N)\nB.ang_vel_in(N)\n\n\\(\\displaystyle 0.5 l \\dot{q}_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle l \\dot{q}_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle \\dot{q}_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\\(\\displaystyle \\dot{q}_{2}\\mathbf{\\hat{a}_x} + \\dot{q}_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\nA0.acc(N)\nB0.acc(N)\n\nA.ang_acc_in(N)\nB.ang_acc_in(N)\n\n\\(\\displaystyle -  0.5 l \\dot{q}_{1}^{2}\\mathbf{\\hat{a}_x} + 0.5 l \\ddot{q}_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle -  l \\dot{q}_{1}^{2}\\mathbf{\\hat{a}_x} + l \\ddot{q}_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle \\ddot{q}_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\\(\\displaystyle \\ddot{q}_{2}\\mathbf{\\hat{a}_x} + \\dot{q}_{1} \\dot{q}_{2}\\mathbf{\\hat{a}_y} + \\ddot{q}_{1}\\mathbf{\\hat{n}_z}\\)\n\n\nSimilarly, we rewrite accelerations and angular accelerations replacing instances of \\(\\dot{q}_{1}\\), \\(\\dot{q}_{2}\\), \\(\\ddot{q}_{1}\\) and \\(\\ddot{q}_{2}\\) with \\(u_{1}\\), \\(u_{2}\\), \\(\\dot{u}_{1}\\) and \\(\\dot{u}_{2}\\)\n\ngeneralised_speeds = {q1.diff(): u1, q2.diff(): u2, q1.diff().diff(): u1.diff(), q2.diff().diff(): u2.diff()}\n\nN_a_A0 = A0.acc(N).xreplace(generalised_speeds)\nN_a_B0 = B0.acc(N).xreplace(generalised_speeds)\n\nN_a_A0\nN_a_B0\n\nN_alpha_A = A.ang_acc_in(N).xreplace(generalised_speeds)\nN_alpha_B = B.ang_acc_in(N).xreplace(generalised_speeds)\n\nN_alpha_A\nN_alpha_B\n\n\\(\\displaystyle -  0.5 l u_{1}^{2}\\mathbf{\\hat{a}_x} + 0.5 l \\dot{u}_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle -  l u_{1}^{2}\\mathbf{\\hat{a}_x} + l \\dot{u}_{1}\\mathbf{\\hat{a}_y}\\)\n\n\n\\(\\displaystyle \\dot{u}_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\\(\\displaystyle \\dot{u}_{2}\\mathbf{\\hat{a}_x} + u_{1} u_{2}\\mathbf{\\hat{a}_y} + \\dot{u}_{1}\\mathbf{\\hat{n}_z}\\)\n\n\n\nmoment_of_inertia_rod = m * l**2 / 12\n\nprint(f\"The principal moment of inertia of a rod about the the plan of \"\n      f\"symmetry orthogonal to the rod length \\n\")\nmoment_of_inertia_rod\n\nThe principal moment of inertia of a rod about the the plan of symmetry orthogonal to the rod length \n\n\n\n\\(\\displaystyle \\frac{l^{2} m}{12}\\)\n\n\n\nI_A_Ao = moment_of_inertia_rod * me.outer(A.y, A.y) + moment_of_inertia_rod * me.outer(A.z, A.z)\nI_B_Bo = moment_of_inertia_rod * me.outer(B.x, B.x) + moment_of_inertia_rod * me.outer(B.z, B.z)\n\nprint(f\"This is the rod A inertia dyadic and its matrix form \\n\")\nI_A_Ao\nI_A_Ao.to_matrix(A)\nprint(f\"\\nThis is the rod B inertia dyadic and its matrix form \\n\")\nI_B_Bo\nI_B_Bo.to_matrix(B)\n\nThis is the rod A inertia dyadic and its matrix form \n\n\n\n\\(\\displaystyle \\frac{l^{2} m}{12}\\mathbf{\\hat{a}_y}\\otimes \\mathbf{\\hat{a}_y} + \\frac{l^{2} m}{12}\\mathbf{\\hat{a}_z}\\otimes \\mathbf{\\hat{a}_z}\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}0 & 0 & 0\\\\0 & \\frac{l^{2} m}{12} & 0\\\\0 & 0 & \\frac{l^{2} m}{12}\\end{matrix}\\right]\\)\n\n\n\nThis is the rod B inertia dyadic and its matrix form \n\n\n\n\\(\\displaystyle \\frac{l^{2} m}{12}\\mathbf{\\hat{b}_x}\\otimes \\mathbf{\\hat{b}_x} + \\frac{l^{2} m}{12}\\mathbf{\\hat{b}_z}\\otimes \\mathbf{\\hat{b}_z}\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}\\frac{l^{2} m}{12} & 0 & 0\\\\0 & 0 & 0\\\\0 & 0 & \\frac{l^{2} m}{12}\\end{matrix}\\right]\\)\n\n\n\nR_Ao_star = -m * N_a_A0\nR_Bo_star = -m * N_a_B0\n\nF1_star = me.dot(v_A0_1, R_Ao_star) + me.dot(v_B0_1, R_Bo_star)\nF2_star = me.dot(v_A0_2, R_Ao_star) + me.dot(v_B0_2, R_Bo_star)\n\n\nT_A_star = -( \n    me.dot(N_alpha_A, I_A_Ao) + me.dot( me.cross(N_w_A, I_A_Ao), N_w_A )\n)\nT_B_star = -( \n    me.dot(N_alpha_B, I_B_Bo) + me.dot( me.cross(N_w_B, I_B_Bo), N_w_B )\n)\n\nT1_star = me.dot(w_A_1, T_A_star) + me.dot(w_B_1, T_B_star)\nT2_star = me.dot(w_A_2, T_A_star) + me.dot(w_B_2, T_B_star)\n\n\nR_Ao_star, R_Bo_star\n\nT_A_star\nT_B_star\n\n\\(\\displaystyle \\left( 0.5 l m u_{1}^{2}\\mathbf{\\hat{a}_x} -  0.5 l m \\dot{u}_{1}\\mathbf{\\hat{a}_y}, \\  l m u_{1}^{2}\\mathbf{\\hat{a}_x} -  l m \\dot{u}_{1}\\mathbf{\\hat{a}_y}\\right)\\)\n\n\n\\(\\displaystyle -  \\frac{l^{2} m \\dot{u}_{1}}{12}\\mathbf{\\hat{a}_z}\\)\n\n\n\\(\\displaystyle (- \\frac{l^{2} m u_{1}^{2} \\sin{\\left(q_{2} \\right)} \\cos{\\left(q_{2} \\right)}}{12} - \\frac{l^{2} m \\dot{u}_{2}}{12})\\mathbf{\\hat{b}_x} + (- \\frac{l^{2} m \\left(- u_{1} u_{2} \\sin{\\left(q_{2} \\right)} + \\cos{\\left(q_{2} \\right)} \\dot{u}_{1}\\right)}{12} + \\frac{l^{2} m u_{1} u_{2} \\sin{\\left(q_{2} \\right)}}{12})\\mathbf{\\hat{b}_z}\\)\n\n\n\nF1 = F1_star + T1_star\nF2 = F2_star + T2_star\n\n\nGIF = sm.Matrix([F1, F2])\nGIF\n\n\\(\\displaystyle \\left[\\begin{matrix}- 1.33333333333333 l^{2} m \\dot{u}_{1} + \\left(- \\frac{l^{2} m \\left(- u_{1} u_{2} \\sin{\\left(q_{2} \\right)} + \\cos{\\left(q_{2} \\right)} \\dot{u}_{1}\\right)}{12} + \\frac{l^{2} m u_{1} u_{2} \\sin{\\left(q_{2} \\right)}}{12}\\right) \\cos{\\left(q_{2} \\right)}\\\\- \\frac{l^{2} m u_{1}^{2} \\sin{\\left(q_{2} \\right)} \\cos{\\left(q_{2} \\right)}}{12} - \\frac{l^{2} m \\dot{u}_{2}}{12}\\end{matrix}\\right]\\)\n\n\n\n\nEQUATIONS OF MOTION\n\nq = sm.Matrix([q1, q2])\nu = sm.Matrix([u1, u2])\n\nqd = q.diff(t)\nud = u.diff(t)\n\nud_zerod = {udr: 0 for udr in ud}\n\nMk = -sm.eye(3)\ngk = u\n\nMd = GIF.jacobian(ud)\ngd = GIF.xreplace(ud_zerod) + GAF\n\n\nMk\ngk\n\n\\(\\displaystyle \\left[\\begin{matrix}-1 & 0 & 0\\\\0 & -1 & 0\\\\0 & 0 & -1\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}u_{1}\\\\u_{2}\\end{matrix}\\right]\\)\n\n\n\nMd\ngd\n\n\\(\\displaystyle \\left[\\begin{matrix}- \\frac{l^{2} m \\cos^{2}{\\left(q_{2} \\right)}}{12} - 1.33333333333333 l^{2} m & 0\\\\0 & - \\frac{l^{2} m}{12}\\end{matrix}\\right]\\)\n\n\n\\(\\displaystyle \\left[\\begin{matrix}- 1.5 g l m \\sin{\\left(q_{1} \\right)} - k q_{1} + \\frac{l^{2} m u_{1} u_{2} \\sin{\\left(q_{2} \\right)} \\cos{\\left(q_{2} \\right)}}{6}\\\\- k q_{2} - \\frac{l^{2} m u_{1}^{2} \\sin{\\left(q_{2} \\right)} \\cos{\\left(q_{2} \\right)}}{12}\\end{matrix}\\right]\\)"
  }
]